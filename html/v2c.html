<HTML>
<HEAD>
<TITLE>PySNMP: SNMP message: Version 2c</TITLE>
</HEAD>

<BODY BGCOLOR="#ffffff" TEXT="#000000"
      LINK="#0000bb"  VLINK="#551a8b" ALINK="#ff0000">
<H3>
SNMP message, version 2c (community based)
</H3>
<P>
The pysnmp.v2c module implememts a set of tools aimed at handling SNMP
messages  of various types, as introduced by version 2c of SNMP protocol.
</P>
<P>
<DL>
<DT>class <STRONG>GETREQUEST</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>SETREQUEST</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>GETNEXTREQUEST</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>RESPONSE</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>INFORMREQUEST</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>TRAP</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>REPORT</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DT>class <STRONG>GETBULKREQUEST</STRONG>([<STRONG>kwargs</STRONG>])</DT>
<DD>
<P>
Instances of these classes represent SNMP message of corresponding type
of SNMP protocol version 2c. The optional <STRONG>kwargs</STRONG> keyword
arguments may be used to initialize arbitrary SNMP message components
(read on).
</P>
<P>
Alternatively, a standard dictionary interface can be used against these
objects for accessing particular message item, though only a fixed set of
keys are allowed. Here is a brief illustration of this concept:
</P>
</DD>
<P>
<PRE>
>>> from pysnmp import v2c
>>> req = v2c.GETREQUEST()
>>> req.keys()
['encoded_oids', 'encoded_vals', 'request_id', 'error_status', 'tag', 
'error_index', 'version', 'community']
>>> req['community'] = 'mycommunity'
>>> repr(req)
"GETREQUEST(encoded_oids=[], encoded_vals=[], request_id=0, error_status=0,
tag='GETREQUEST', error_index=0, version=1, community='mycommunity')"
>>>
</PRE>
</P>
<P>
As it can be seen from the above example, the following key/keyword values
are allowed to instances of the <STRONG>GETREQUEST</STRONG>,
<STRONG>SETREQUEST</STRONG>, <STRONG>GETNEXTREQUEST</STRONG>,
<STRONG>TRAP</STRONG>, <STRONG>INFORMREQUEST</STRONG> and
<STRONG>REPORT</STRONG> classes:
</P>
<P>
<UL>
<LI><STRONG>version</STRONG> - SNMP protocol version being used (default 0)
<LI><STRONG>comminuty</STRONG> - SNMP community name (default 'public')
<LI><STRONG>request_id</STRONG> - SNMP request ID (default 0)
<LI><STRONG>error_status</STRONG> - SNMP error ID (default 0)
<LI><STRONG>error_index</STRONG> - position of errornous OID-value pair
(default 0)
<LI><STRONG>encoded_oids</STRONG> - a list of BER encoded ASN.1 Object ID's
(default [])
<LI><STRONG>encoded_vals</STRONG> - a list of BER encoded values (default [])
</UL>
</P>
<P>
Instances of GETBULKREQUEST() class accept the following key/keyword arguments:
</P>
<P>
<UL>
<LI><STRONG>version</STRONG> - SNMP protocol version being used (default 0)
<LI><STRONG>comminuty</STRONG> - SNMP community name (default 'public')
<LI><STRONG>non_repeaters</STRONG> - non-repeating Object IDs in
Object ID / value binding (default 0) 
<LI><STRONG>max_repetitions</STRONG> - max repetitions of repeating Object IDs
in Object ID / value binding (default 0)
<LI><STRONG>encoded_oids</STRONG> - a list of BER encoded ASN.1 Object ID's
(default [])
<LI><STRONG>encoded_vals</STRONG> - a list of BER encoded values (default [])
</UL>
</P>
<P>
The <STRONG>encoded_oids</STRONG> and <STRONG>encoded_vals</STRONG> parameters
can be handled by the instances of corresponding classes from
<A HREF="asn1.html"> SNMP subset of ASN.1 data types</A> module. Here is an
example of how this could be done:
</P>
<P>
<PRE>
>>> from pysnmp import asn1
>>> map(asn1.OBJECTID().encode, ['1.3.6.1.2.1.1.1.0'])
['\006\010+\006\001\002\001\001\001\000']
>>>
</PRE>
</P>
<P>
The Object IDs and their respective values are matched against each other
by their positions in the <STRONG>encoded_oids</STRONG> and
<STRONG>encoded_vals</STRONG> lists.
</P>
</DL>

<DL>
<DT>def <STRONG>decode</STRONG>(<STRONG>data</STRONG>)</DT>
<DD>
<P>
The <STRONG>decode</STRONG> function takes SNMP message carried in a
BER-encoded octet-stream <STRONG>data</STRONG>, and decodes it into a SNMP
message object of matching type.
</P>
<P>
A tuple of (<STRONG>snmp_message_object</STRONG>, <STRONG>rest</STRONG>) is
returned where <STRONG>snmp_message_object</STRONG> is an instance of a SNMP
message class, matching SNMP message type, and the <STRONG>rest</STRONG> is
the unprocessed part of input. The <STRONG>decode</STRONG> function also 
accepts SNMP messages of version 1 of SNMP protocol. In that case, an instance
of corresponding <A HREF="v2c.html">v2c</A>.* class is returned.
</P>
</DD>
</DL>

<DL>
<DT>exception <STRONG>Error</STRONG></DT>
<DD>
<P>
Exception raised on any error in the <STRONG>pysnmp.v2c</STRONG> module,
as well as in its base (<STRONG>pysnmp.v1</STRONG>) and derivative modules.
This exception class is a subclass of the <STRONG>v1.Error</STRONG> class.
</P>
<P>
See documentation on the <A HREF="error.html">error.General</A> base class for
usage details.
</P>
</DD>
</DL>

<P>
The following exceptions are derived from this class:
</P>

<DL>
<DT>exception <STRONG>BadPDUType</STRONG></DT>
<DD>
<P>
Unknown BER tag for in SNMP PDU.
</P>
</DD>
</DL>

<DL>
<DT>exception <STRONG>BadVersion</STRONG></DT>
<DD>
<P>
Unsupported SNMP version.
</P>
</DD>
</DL>

<DL>
<DT>exception <STRONG>BadEncoding</STRONG></DT>
<DD>
<P>
Malformed BER octet-stream.
</P>
</DD>
</DL>

<HR><STRONG>Subsections</STRONG>

<P>
<UL>
<LI>Objects of the <A HREF="v2c-getrequest-objects.html">
<STRONG>v2c.GETREQUEST</STRONG>, <STRONG>v2c.SETREQUEST</STRONG>,
<STRONG>v2c.GETNEXTREQUEST</STRONG>, <STRONG>v2c.TRAP</STRONG>,
<STRONG>v2c.INFORMREQUEST</STRONG>, <STRONG>v2c.REPORT</STRONG>
and <STRONG>v2c.GETBULKREQUEST</STRONG></A> classes
<LI>Objects of the <A HREF="v2c-response-objects.html">
<STRONG>v2c.RESPONSE</STRONG></A> class
</UL>
</P>

<HR>

<ADDRESS>
ilya@glas.net
</ADDRESS>

</BODY>
</HTML>
